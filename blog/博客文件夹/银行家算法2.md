# 银行家算法

## 一、安全序列

在某一时刻，系统中存在某种顺序{P[1],P[2],...,P[n]}，使得此时所有进程都能获得其所需的资源，并顺利完成所有进程，则称该系统此时的状态为安全状态，称这样的序列为安全序列

### 安全序列的实质：序列中每一个进程Pi到运行完成尚需的资源量不超过系统当前剩余资源量与所有在序列中排在它前面的进程所占用的资源量之和

**注意：**

**系统的安全状态可能不唯一 **

**安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态仅仅可能进入死锁**

![image-20221205204418131](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221205204418131.png)

## 二、银行家算法

### 实质：

银行家算法的实质是要设法保证系统动态分配资源后，系统依然保证处于安全状态，从而避免死锁。即：系统将判断每个进程请求资源后，系统状态是否依然处于安全状态，如果安全，则给该进程分配资源，否则不予分配，进程将阻塞。

### 前提：

要求进程预先剔除自己的最大资源请求，且假设西塔拥有固定的资源总量。

### 银行家算法主要数据结构：

1. 可用资源向量 available——记录系统中各类资源当前可利用数目
2. 最大需求矩阵 max——记录每个进程对各类资源的最大需求量
3. 分配矩阵 allocation——记录每个进程对各类资源当前的占有量
4. 需求矩阵 need——记录每个进程对各类资源仍然需要地数目，等于最大需求矩阵与分配矩阵的差
5. 请求向量 request——记录某个进程对当前各类资源的申请量，是银行家算法的入口参数

### 银行家算法描述如下（设进程P[i]向系统提出request[i]资源请求）

1. 若 request[i] > need[i]，则进程P[i]出错

2. 若request[i] > available[i]， 则进程P[i]阻塞

3. 系统试着把资源分配给进程P[i]，并对相应数据结构作出修改：
```java
available[i] -= request[i]; 
allocation[i] += request[i]; 
need[i] -= request[i];
```

4. 系统执行安全性检测子算法，以判断试分配后系统状态是否安全
5. 若 4 返回为真，则完成本次分配，返回；
6. 否则撤销本次的试分配，进程P[i]阻塞

![image-20221207173930418](D:\谭远\typora文件\博客文件夹\image-20221207173930418.png)

### 安全检测子算法

银行家算法的核心是在4 步中调用的安全性检测子算法，这个子算法实质上就是个寻找安全序列的过程，如果找到则返回真，表示系统安全，反之表示系统不安全。该子算法用的主要数据结构基于银行家算法，但另外增加了两个向量：

工作向量work与进程可完成标志向量finish。

work记录系统中各类资源的当前可用数目，他是available的替身，以便简化主算法撤销分配的实现。

finish记录进程是否可完成。

#### 子算法执行过程

1. 初始化：work = available；finish = false；
2. 若按进程编号的顺序找到了一个可加入安全序列的进程（finish[i] = false && need[i] <= work）P[i]，则假设该进程不久将完成任务归还资源，于是置work = work + allocation[i] 以及 finish[i] = true；然后重复执行这一步
3. 若所有进程的finish标志位站，则安全，否则表示不安全

#### 流程图

## 具体实例

假定操作系统中的四个进程P1、P2、P3、P4和三类资源R1、R2、R3（资源数量分别为9、3、6），在t0时刻的资源分配情况如表所示

![image-20221229175600985](D:\谭远\typora文件\博客文件夹\image-20221229175600985.png)
